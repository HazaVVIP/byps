byps/
├── CMakeLists.txt                    # C++ build configuration: defines project, dependencies (Boost, OpenSSL), compiler flags (-std=c++17, -O3), and links all source files
├── Cargo.toml                        # Rust package manifest: defines dependencies (clap, tokio, serde, cc), build script reference, and FFI configuration
├── build.rs                          # Rust build script: compiles C++ code using cc crate, links libraries, generates FFI bindings, sets up include paths
├── README.md                         # Project documentation: installation guide, usage examples, feature list, architecture overview, contribution instructions
├── LICENSE                           # License file: MIT or GPL-3.0 recommended for security tools
├── .gitignore                        # Git ignore: excludes target/, build/, *.o, *.so, .vscode/, .idea/, compiled binaries
│
├── cpp/
│   ├── include/
│   │   ├── byps.h                    # Main C API header: extern "C" declarations for FFI, exposes core functions to Rust (byps_init, byps_scan, byps_cleanup)
│   │   │
│   │   ├── common/
│   │   │   ├── types.hpp             # Common types: RequestConfig struct (url, timeout, retries), BypassResult struct (success, status_code, technique_used, response_time), WAFInfo struct (type, confidence, headers)
│   │   │   ├── logger.hpp            # Logging system: Logger class with levels (DEBUG, INFO, WARN, ERROR), thread-safe logging, file/console output, configurable verbosity
│   │   │   ├── error.hpp             # Error handling: ErrorCode enum (SUCCESS, NETWORK_ERROR, PARSE_ERROR, TIMEOUT, WAF_DETECTED), custom exception classes with stack traces
│   │   │   └── utils.hpp             # Utility functions: string manipulation (trim, split, join), URL parsing/encoding, base64/hex encoding, random string generation, timing utilities
│   │   │
│   │   ├── core/
│   │   │   ├── engine.hpp            # Main bypass engine: BypassEngine class, orchestrates all techniques, manages technique priority, handles retries, aggregates results, implements smart fallback strategies
│   │   │   ├── packet.hpp            # Raw packet manipulation: RawPacket class, TCP/IP packet crafting, custom checksum calculation, packet fragmentation, low-level send/receive with socket options
│   │   │   ├── http_parser.hpp       # Custom HTTP parser: HTTPRequest/HTTPResponse classes, lenient parsing (handles malformed responses), header/body extraction, chunked encoding support, handles edge cases WAF might miss
│   │   │   ├── socket.hpp            # Low-level socket operations: Socket class (TCP/UDP), non-blocking I/O, timeout handling, connection pooling, SSL/TLS wrapper, socket options (SO_REUSEADDR, TCP_NODELAY)
│   │   │   └── request_builder.hpp   # Fluent request builder: RequestBuilder class with method chaining (.url().method().header().body()), validates requests, supports all HTTP methods, handles encoding automatically
│   │   │
│   │   ├── techniques/
│   │   │   ├── path_bypass.hpp       # Path manipulation: implements /admin -> /admin/ -> /admin.. -> /./admin -> /%2e/admin -> /admin;/ -> /ADMIN -> /admin%20 -> /admin%09 -> /admin%00, case variation, path traversal, null byte injection
│   │   │   ├── header_forge.hpp      # Header forgery: X-Forwarded-For (127.0.0.1, localhost), X-Original-URL, X-Rewrite-URL, X-Custom-IP-Authorization, Host header manipulation, header injection (CRLF), custom header ordering
│   │   │   ├── protocol_abuse.hpp    # HTTP protocol abuses: HTTP/0.9 requests, HTTP/1.0 vs 1.1 differences, missing Host header, duplicate headers, invalid Content-Length, Transfer-Encoding tricks, connection handling abuse
│   │   │   ├── encoding.hpp          # Custom encoding: URL encoding (single, double, triple), Unicode encoding (UTF-8, UTF-16), HTML entity encoding, case variation, mixed encoding, charset tricks, normalization bypasses
│   │   │   ├── timing.hpp            # Timing-based techniques: race conditions, TOCTOU attacks, precise microsecond delays, jitter injection, rate limit bypass timing, slow HTTP attacks (Slowloris-style for testing)
│   │   │   ├── smuggling.hpp         # HTTP request smuggling: CL.TE (Content-Length vs Transfer-Encoding), TE.CL, TE.TE variants, chunk size manipulation, desync detection, pipeline abuse, automated chain building
│   │   │   └── unicode.hpp           # Unicode normalization: NFKC/NFKD normalization, homograph attacks, Unicode case folding, zero-width characters, bidirectional override, confusables, UTF-8 overlong encoding
│   │   │
│   │   ├── waf/
|   │   │   ├── fingerprint.hpp       # WAF fingerprinting: identifies WAF by response headers (Server, X-CDN), error page signatures, timing analysis, cookie patterns, specific header combinations, returns confidence score
│   │   │   ├── evasion.hpp           # WAF-specific evasions: per-WAF bypass techniques (Cloudflare, Akamai, AWS, Imperva), signature avoidance, payload mutation, automated technique selection based on detected WAF
│   │   │   ├── payload.hpp           # Payload obfuscation: polymorphic payloads, string fragmentation, encoding stacking, comment injection, whitespace manipulation, case randomization, garbage insertion
│   │   │   └── detector.hpp          # WAF type detection: analyzes responses to determine WAF type, checks error pages, response timing patterns, header analysis, builds WAF profile, suggests best bypass techniques
│   │   │
│   │   ├── network/
│   │   │   ├── tcp.hpp               # TCP layer manipulation: custom TCP flags (PSH, URG), sequence number manipulation, window size tricks, segment fragmentation, out-of-order delivery, TCP options abuse, SYN flood protection bypass
│   │   │   ├── tls.hpp               # Custom TLS handling: TLS version negotiation, custom cipher suites, SNI manipulation, ALPN protocol selection, certificate validation bypass (testing only), TLS fingerprint randomization
│   │   │   ├── http2.hpp             # HTTP/2 abuse techniques: stream multiplexing attacks, HPACK header compression tricks, priority manipulation, flow control abuse, server push exploitation, downgrade attacks
│   │   │   └── dns.hpp               # DNS manipulation: DNS cache poisoning (testing), rebinding attacks, custom DNS resolution, hosts file bypass, split-horizon DNS, DNSSEC bypass techniques
│   │   │
│   │   └── scanner/
│   │       ├── strategy.hpp          # Scanning strategies: FastStrategy (common techniques only), ThoroughStrategy (all techniques, all permutations), StealthStrategy (slow, random delays, single thread), CustomStrategy (user-defined)
│   │       └── result.hpp            # Result management: ScanResult class, aggregates all bypass attempts, success/failure tracking, timing statistics, technique effectiveness ranking, generates summary reports
│   │
│   ├── src/
│   │   ├── common/
│   │   │   ├── types.cpp             # Implementation of common types: struct constructors, serialization/deserialization, validation methods, copy/move semantics
│   │   │   ├── logger.cpp            # Logger implementation: file rotation, timestamp formatting, thread-safe queue, async writing, log level filtering, colored console output
│   │   │   ├── error.cpp             # Error handling implementation: exception constructors, error message formatting, stack trace capture (using libbacktrace or similar), error code to string mapping
│   │   │   └── utils.cpp             # Utility implementations: string algorithms, URL parser (scheme/host/port/path extraction), encoding/decoding functions, PRNG initialization, time measurement helpers
│   │   │
│   │   ├── core/
│   │   │   ├── engine.cpp            # Engine implementation: technique orchestration logic, priority queue management, parallel execution coordinator, result aggregation, automatic technique selection, adaptive retry logic
│   │   │   ├── packet.cpp            # Packet implementation: raw socket creation, IP/TCP header construction, checksum calculation (RFC 793), packet serialization, error handling for EPERM/EACCES
│   │   │   ├── http_parser.cpp       # Parser implementation: state machine for HTTP parsing, header parsing (handles duplicates, whitespace), chunked decoding, handles incomplete responses, buffer management
│   │   │   ├── socket.cpp            # Socket implementation: socket()/connect()/send()/recv() wrappers, non-blocking mode (fcntl), timeout with select()/poll(), SSL context setup (OpenSSL), connection pooling with LRU eviction
│   │   │   └── request_builder.cpp   # Builder implementation: method chaining implementation, request validation, automatic header insertion (User-Agent, Accept), body encoding, URL normalization
│   │   │
│   │   ├── techniques/
│   │   │   ├── path_bypass.cpp       # Path bypass implementation: generates all path variations, URL encoding at different levels, case permutations, path normalization bypass, null byte tricks, implements 20+ variations
│   │   │   ├── header_forge.cpp      # Header forge implementation: generates IP spoofing headers, URL rewrite headers, custom authorization headers, header injection payloads, tests 30+ header combinations
│   │   │   ├── protocol_abuse.cpp    # Protocol abuse implementation: crafts HTTP/0.9, HTTP/1.0, malformed requests, duplicate header injection, conflicting Content-Length/Transfer-Encoding, connection abuse
│   │   │   ├── encoding.cpp          # Encoding implementation: multiple encoding layers, charset tricks, UTF-8 overlong sequences, Unicode normalization bypass, mixed encoding, implements 15+ encoding schemes
│   │   │   ├── timing.cpp            # Timing implementation: high-resolution sleep (nanosleep), jitter calculation, race condition orchestration, rate limit detection, adaptive timing adjustment
│   │   │   ├── smuggling.cpp         # Smuggling implementation: CL.TE/TE.CL/TE.TE payload generation, automatic desync detection, chain request building, response correlation, timing-based detection
│   │   │   └── unicode.cpp           # Unicode implementation: normalization algorithms (NFC, NFD, NFKC, NFKD), homograph generation, confusable character mapping, bidirectional text manipulation, zero-width insertion
│   │   │
│   │   ├── waf/
│   │   │   ├── fingerprint.cpp       # Fingerprint implementation: header signature database, regex-based pattern matching, timing profile analysis, statistical confidence calculation, WAF version detection
│   │   │   ├── evasion.cpp           # Evasion implementation: WAF-specific technique database (Cloudflare: cache key manipulation, Akamai: cookie handling, AWS: HMAC bypass), automatic technique selection
│   │   │   ├── payload.cpp           # Payload implementation: polymorphic generation engine, mutation algorithms, signature evasion, garbage data insertion, payload validation, maintains semantic equivalence
│   │   │   └── detector.cpp          # Detector implementation: active probing (sends test requests), passive analysis (header inspection), machine learning classification (optional), confidence scoring algorithm
│   │   │
│   │   ├── network/
│   │   │   ├── tcp.cpp               # TCP implementation: raw socket programming, TCP header struct, flag manipulation, sequence number handling, fragmentation logic, checksum calculation, handles ICMP errors
│   │   │   ├── tls.cpp               # TLS implementation: OpenSSL/BoringSSL wrapper, custom ClientHello generation, cipher suite selection, SNI manipulation, ALPN handling, session resumption, fingerprint randomization
│   │   │   ├── http2.cpp             # HTTP/2 implementation: HPACK compression/decompression, stream management, frame serialization, priority tree manipulation, flow control, server push handling
│   │   │   └── dns.cpp               # DNS implementation: custom DNS queries, cache poisoning payloads (for testing), rebinding attack orchestration, custom resolver, handles A/AAAA/CNAME records
│   │   │
│   │   └── scanner/
│   │       ├── strategy.cpp          # Strategy implementation: strategy pattern classes, technique selection logic, execution order optimization, parallel vs sequential execution, resource management, progress tracking
│   │       └── result.cpp            # Result implementation: result aggregation, success rate calculation, technique ranking by effectiveness, timing statistics (min/max/avg/median), JSON/text report generation
│   │
│   └── lib/
│       └── byps_core.cpp             # C API wrapper: extern "C" function implementations, C++ exception to error code conversion, memory management (malloc/free), thread safety (mutex), FFI-safe types, initialization/cleanup
│
├── src/                              # Rust layer
│   ├── main.rs                       # CLI entry point: parses arguments using clap, validates input, calls bridge functions, handles Ctrl+C, displays progress bar, error handling, exit codes
│   ├── lib.rs                        # Library root: re-exports all public modules, FFI function declarations (extern "C"), integration tests can use this as library
│   ├── cli.rs                        # Argument parsing: clap-based CLI definition, subcommands (scan, detect, test), argument validation (URL format, file existence), help text, examples in --help
│   ├── bridge.rs                     # FFI bridge: unsafe FFI calls to C++, type conversion (Rust String <-> C char*), error handling (converts C error codes to Rust Result), memory safety wrappers
│   ├── output/
│   │   ├── mod.rs                    # Output module: re-exports all output formats, OutputFormat enum, trait for common output interface
│   │   ├── json.rs                   # JSON output: serde_json serialization, pretty-print option, schema-compliant output, includes all result fields, supports streaming for large results
│   │   ├── csv.rs                    # CSV output: csv crate usage, header row definition, field escaping, supports appending to existing files, configurable delimiter
│   │   ├── html.rs                   # HTML output: generates styled HTML report with CSS, color-coded results (green/red), sortable tables, includes metadata (timestamp, target, statistics)
│   │   └── terminal.rs               # Terminal output: colored output (success=green, fail=red), progress bar (indicatif), real-time updates, table formatting, Unicode support, respects NO_COLOR env var
│   ├── config.rs                     # Config management: YAML parsing (serde_yaml), config file loading from disk, merges CLI args with config file, validation, default values, config struct definition
│   └── error.rs                      # Rust error handling: custom Error enum (NetworkError, ParseError, ConfigError), implements std::error::Error, From implementations for conversions, error context with anyhow
│
├── wordlists/
│   ├── paths.txt                     # Path variations: common admin paths (/admin, /administrator, /wp-admin, /phpmyadmin), path traversal patterns, encoded versions, 500+ entries
│   ├── headers.txt                   # Header names: X-Forwarded-For, X-Original-URL, X-Rewrite-URL, X-Custom-IP-Authorization, CF-Connecting-IP, True-Client-IP, 50+ headers
│   ├── advanced_payloads.txt         # Advanced payloads: HTTP smuggling templates, Unicode tricks, complex encoding chains, polyglot payloads, 100+ entries
│   ├── methods.txt                   # HTTP methods: GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS, TRACE, CONNECT, custom methods (GETT, POSTX), case variations
│   ├── encodings.txt                 # Encoding schemes: URL encoding patterns (%2e, %252e), Unicode escapes (\u002e), HTML entities (&period;), mixed encodings
│   └── user_agents.txt               # User agents: browser UAs (Chrome, Firefox, Safari), bot UAs (Googlebot, internal scanners), custom UAs, 200+ entries
│
├── configs/
│   ├── default.yaml                  # Default config: balanced approach, timeout=10s, retries=3, concurrent=10, all techniques enabled, medium verbosity
│   ├── aggressive.yaml               # Aggressive config: fast scanning, timeout=5s, retries=1, concurrent=50, all techniques+variations, no stealth
│   ├── stealth.yaml                  # Stealth config: slow scanning, timeout=30s, random delays (1-5s), concurrent=1, limited techniques, mimics human behavior
│   └── waf_specific/
│       ├── cloudflare.yaml           # Cloudflare config: techniques known to work on Cloudflare (cache key manipulation, origin exposure), specific headers, timing adjustments
│       ├── akamai.yaml               # Akamai config: Akamai-specific techniques (ghost headers, cookie manipulation), pragma handling
│       └── aws_waf.yaml              # AWS WAF config: AWS-specific bypasses (signature version tricks, regional differences), metadata service abuse
│
├── docs/
│   ├── ARCHITECTURE.md               # Architecture doc: system design overview, component interaction diagram, data flow, threading model, extension points, design decisions rationale
│   ├── TECHNIQUES.md                 # Techniques doc: detailed explanation of each bypass technique, when to use, examples, success rates, references to research papers/blogs
│   ├── API.md                        # API documentation: C++ API reference, Rust API reference, FFI interface, example code snippets, integration guide
│   └── CONTRIBUTING.md               # Contributing guide: how to add new techniques, code style (clang-format, rustfmt), PR process, testing requirements, code review guidelines
│
├── examples/
│   ├── basic_usage.sh                # Basic usage: simple one-liner examples, common use cases, explains each flag, expected output examples
│   ├── advanced_bypass.sh            # Advanced usage: complex scenarios, chaining techniques, using config files, parsing output with jq
│   └── custom_technique.cpp          # Custom technique: example C++ code showing how to implement a new bypass technique, inheritance from base class, integration guide
│
├── scripts/
│   ├── build.sh                      # Build script: builds both C++ and Rust, handles dependencies, creates release binary, supports debug/release modes, cross-compilation support
│   ├── test.sh                       # Test runner: runs C++ tests (gtest), Rust tests (cargo test), integration tests, generates coverage report (lcov/tarpaulin)
│   └── install.sh                    # Installation: copies binary to /usr/local/bin, installs man page, creates config directory, checks dependencies
│
├── tests/
│   ├── cpp/
│   │   ├── CMakeLists.txt            # Test build config: GoogleTest integration, defines test targets, links against main library, coverage flags
│   │   ├── test_engine.cpp           # Engine tests: unit tests for BypassEngine, mocks for techniques, tests orchestration logic, edge cases
│   │   ├── test_parser.cpp           # Parser tests: HTTP parsing edge cases, malformed requests/responses, chunked encoding, buffer overflows
│   │   ├── test_techniques.cpp       # Technique tests: validates each technique generates correct payloads, checks encoding correctness, mutation quality
│   │   └── test_network.cpp          # Network tests: socket operations, timeout handling, connection pooling, error conditions (ECONNREFUSED, ETIMEDOUT)
│   ├── integration/
│   │   ├── test_bypass.rs            # Bypass integration tests: end-to-end tests against mock server, validates successful bypasses, checks output format
│   │   └── test_waf.rs               # WAF integration tests: tests against simulated WAF, validates detection accuracy, evasion effectiveness
│   └── fixtures/
│       ├── sample_responses/         # Sample responses: HTTP response files for testing parser, various status codes (401, 403, 200), edge cases
│       └── test_payloads/            # Test payloads: known bypass payloads for validation, positive/negative test cases, encoded variations
│
├── benchmarks/
│   ├── bench_parser.cpp              # Parser benchmarks: measures parsing speed (requests/sec), memory usage, compares against standard parsers
│   └── bench_techniques.cpp          # Technique benchmarks: measures technique execution time, payload generation speed, identifies bottlenecks
│
└── .github/
    ├── workflows/
    │   ├── ci.yml                    # CI pipeline: runs on push/PR, builds on Linux/macOS/Windows, runs tests, checks code format (clang-format, rustfmt), uploads artifacts
    │   └── release.yml               # Release automation: triggers on tag, builds release binaries for multiple platforms, creates GitHub release, uploads binaries, generates changelog
    └── ISSUE_TEMPLATE/
        └── bug_report.md             # Bug report template: structured issue template, asks for version, OS, reproduction steps, expected vs actual behavior, logs
